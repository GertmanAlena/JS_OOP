<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>

        // async/await
        // Функционал async/await для работы с асинхронным кодом (а именно для работы с
        // обещаниями) появился в JS с приходом стандарта ES7, и пока еще не слишком
        // поддерживается браузерами, но есть полифилы для работы с ними.
        // Суть подхода async/await - это писать асинхронный код так, будто он выполняется
        // синхронно, но при этом не блокирует основной поток выполнения. Подход состоит
        // из применения двух операторов:
        // ● async - пишется перед функцией и превращает любую функцию в обещание, а
        // также позволяет использовать второй оператор await внутри себя.
        // 22
        // ● await - оператор пишется перед вызовом асинхронной функции, что
        // заставляет код остановиться в этом месте, пока асинхронная функция не
        // вернет результат.


        const getUser = async (url) => {
            // Делаем запрос, и ждем его результат (указание await),
            // который будет сохранен в константу response.
            const response = await fetch(url);
            // Выполняем еще один асинхронный метод, преобразования в
            // текст, также ждем результат, который сохраняется в константу
            // пользователь.
            const user = await response.text();
            console.log(user);
        }
        getUser('https://api.github.com/users/octocat');
        // Вывод в консоль.
        // {
        // "login": "octocat",
        // "id": 583231,
        // ...
        // }

        //***********  “Запланированная асинхронность” -  setTimeout, setInterval

        const timerId = setInterval(() => {
            if (counter > amount) {
            // После того как наш счетчик достигнет нужного
            // количества итераций, мы должны очистить таймер, чтобы итерации
            // больше не выполнялись.
                clearInterval(timerId);
                console.log('End long calculations');
            }
            // Добавим вывод нашего счетчика через каждые 10000 итераций,
            // чтобы видеть что наш код работает.
            if(counter % 10000 === 0) {
                console.log('working: ', counter);
            }
            const newDate = new Date(counter);
            counter++;
        }, 0);
        // Start long calculations
        // working: 0
        // working: 10000
        // working: 20000
        // End long calculations

    </script>
</body>

</html>